// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dataTypespb/dataTypes.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_dataTypespb_2fdataTypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_dataTypespb_2fdataTypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dataTypespb_2fdataTypes_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dataTypespb_2fdataTypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_dataTypespb_2fdataTypes_2eproto;
namespace dataTypespb {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockHeader;
struct BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class Blocks;
struct BlocksDefaultTypeInternal;
extern BlocksDefaultTypeInternal _Blocks_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class Logs;
struct LogsDefaultTypeInternal;
extern LogsDefaultTypeInternal _Logs_default_instance_;
class Penny;
struct PennyDefaultTypeInternal;
extern PennyDefaultTypeInternal _Penny_default_instance_;
class PennyWithSenderHash;
struct PennyWithSenderHashDefaultTypeInternal;
extern PennyWithSenderHashDefaultTypeInternal _PennyWithSenderHash_default_instance_;
class Receipt;
struct ReceiptDefaultTypeInternal;
extern ReceiptDefaultTypeInternal _Receipt_default_instance_;
class ReceiptHeader;
struct ReceiptHeaderDefaultTypeInternal;
extern ReceiptHeaderDefaultTypeInternal _ReceiptHeader_default_instance_;
class Receipts;
struct ReceiptsDefaultTypeInternal;
extern ReceiptsDefaultTypeInternal _Receipts_default_instance_;
class TransientNonce;
struct TransientNonceDefaultTypeInternal;
extern TransientNonceDefaultTypeInternal _TransientNonce_default_instance_;
}  // namespace dataTypespb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace dataTypespb {
enum Account_State : int {
  Account_State_FINALIZED = 0,
  Account_State_PRECOMMIT = 1,
  Account_State_PREABORT = 2,
  Account_State_CONFLICT = 3,
  Account_State_Account_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Account_State_Account_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Account_State_IsValid(int value);
extern const uint32_t Account_State_internal_data_[];
constexpr Account_State Account_State_State_MIN = static_cast<Account_State>(0);
constexpr Account_State Account_State_State_MAX = static_cast<Account_State>(3);
constexpr int Account_State_State_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Account_State_descriptor();
template <typename T>
const std::string& Account_State_Name(T value) {
  static_assert(std::is_same<T, Account_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return Account_State_Name(static_cast<Account_State>(value));
}
template <>
inline const std::string& Account_State_Name(Account_State value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Account_State_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Account_State_Parse(absl::string_view name, Account_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Account_State>(
      Account_State_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TransientNonce final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.TransientNonce) */ {
 public:
  inline TransientNonce() : TransientNonce(nullptr) {}
  ~TransientNonce() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TransientNonce(
      ::google::protobuf::internal::ConstantInitialized);

  inline TransientNonce(const TransientNonce& from) : TransientNonce(nullptr, from) {}
  inline TransientNonce(TransientNonce&& from) noexcept
      : TransientNonce(nullptr, std::move(from)) {}
  inline TransientNonce& operator=(const TransientNonce& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransientNonce& operator=(TransientNonce&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransientNonce& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransientNonce* internal_default_instance() {
    return reinterpret_cast<const TransientNonce*>(
        &_TransientNonce_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(TransientNonce& a, TransientNonce& b) { a.Swap(&b); }
  inline void Swap(TransientNonce* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransientNonce* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransientNonce* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TransientNonce>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransientNonce& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TransientNonce& from) { TransientNonce::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransientNonce* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.TransientNonce"; }

 protected:
  explicit TransientNonce(::google::protobuf::Arena* arena);
  TransientNonce(::google::protobuf::Arena* arena, const TransientNonce& from);
  TransientNonce(::google::protobuf::Arena* arena, TransientNonce&& from) noexcept
      : TransientNonce(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint64 nonce = 1;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.TransientNonce)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t nonce_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class ReceiptHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.ReceiptHeader) */ {
 public:
  inline ReceiptHeader() : ReceiptHeader(nullptr) {}
  ~ReceiptHeader() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiptHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReceiptHeader(const ReceiptHeader& from) : ReceiptHeader(nullptr, from) {}
  inline ReceiptHeader(ReceiptHeader&& from) noexcept
      : ReceiptHeader(nullptr, std::move(from)) {}
  inline ReceiptHeader& operator=(const ReceiptHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiptHeader& operator=(ReceiptHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiptHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiptHeader* internal_default_instance() {
    return reinterpret_cast<const ReceiptHeader*>(
        &_ReceiptHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ReceiptHeader& a, ReceiptHeader& b) { a.Swap(&b); }
  inline void Swap(ReceiptHeader* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiptHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiptHeader* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReceiptHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReceiptHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReceiptHeader& from) { ReceiptHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReceiptHeader* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.ReceiptHeader"; }

 protected:
  explicit ReceiptHeader(::google::protobuf::Arena* arena);
  ReceiptHeader(::google::protobuf::Arena* arena, const ReceiptHeader& from);
  ReceiptHeader(::google::protobuf::Arena* arena, ReceiptHeader&& from) noexcept
      : ReceiptHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogHashesFieldNumber = 4,
    kContractAddressFieldNumber = 1,
    kGasUsedFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // repeated bytes logHashes = 4;
  int loghashes_size() const;
  private:
  int _internal_loghashes_size() const;

  public:
  void clear_loghashes() ;
  const std::string& loghashes(int index) const;
  std::string* mutable_loghashes(int index);
  void set_loghashes(int index, const std::string& value);
  void set_loghashes(int index, std::string&& value);
  void set_loghashes(int index, const char* value);
  void set_loghashes(int index, const void* value, std::size_t size);
  void set_loghashes(int index, absl::string_view value);
  std::string* add_loghashes();
  void add_loghashes(const std::string& value);
  void add_loghashes(std::string&& value);
  void add_loghashes(const char* value);
  void add_loghashes(const void* value, std::size_t size);
  void add_loghashes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& loghashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_loghashes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_loghashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_loghashes();

  public:
  // bytes contractAddress = 1;
  void clear_contractaddress() ;
  const std::string& contractaddress() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contractaddress(Arg_&& arg, Args_... args);
  std::string* mutable_contractaddress();
  PROTOBUF_NODISCARD std::string* release_contractaddress();
  void set_allocated_contractaddress(std::string* value);

  private:
  const std::string& _internal_contractaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractaddress(
      const std::string& value);
  std::string* _internal_mutable_contractaddress();

  public:
  // uint64 gasUsed = 3;
  void clear_gasused() ;
  ::uint64_t gasused() const;
  void set_gasused(::uint64_t value);

  private:
  ::uint64_t _internal_gasused() const;
  void _internal_set_gasused(::uint64_t value);

  public:
  // bool status = 2;
  void clear_status() ;
  bool status() const;
  void set_status(bool value);

  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.ReceiptHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> loghashes_;
    ::google::protobuf::internal::ArenaStringPtr contractaddress_;
    ::uint64_t gasused_;
    bool status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Penny final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Penny) */ {
 public:
  inline Penny() : Penny(nullptr) {}
  ~Penny() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Penny(
      ::google::protobuf::internal::ConstantInitialized);

  inline Penny(const Penny& from) : Penny(nullptr, from) {}
  inline Penny(Penny&& from) noexcept
      : Penny(nullptr, std::move(from)) {}
  inline Penny& operator=(const Penny& from) {
    CopyFrom(from);
    return *this;
  }
  inline Penny& operator=(Penny&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Penny& default_instance() {
    return *internal_default_instance();
  }
  static inline const Penny* internal_default_instance() {
    return reinterpret_cast<const Penny*>(
        &_Penny_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Penny& a, Penny& b) { a.Swap(&b); }
  inline void Swap(Penny* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Penny* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Penny* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Penny>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Penny& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Penny& from) { Penny::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Penny* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Penny"; }

 protected:
  explicit Penny(::google::protobuf::Arena* arena);
  Penny(::google::protobuf::Arena* arena, const Penny& from);
  Penny(::google::protobuf::Arena* arena, Penny&& from) noexcept
      : Penny(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmountFieldNumber = 3,
    kSenderFieldNumber = 4,
    kDestinationFieldNumber = 5,
    kDataFieldNumber = 6,
    kOriginChainFieldNumber = 8,
    kDestinationChainFieldNumber = 9,
    kSenderTransactionIdFieldNumber = 1,
    kTimestampFieldNumber = 7,
  };
  // bytes amount = 3;
  void clear_amount() ;
  const std::string& amount() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* value);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // bytes sender = 4;
  void clear_sender() ;
  const std::string& sender() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* value);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // bytes destination = 5;
  void clear_destination() ;
  const std::string& destination() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* value);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // bytes data = 6;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // bytes originChain = 8;
  void clear_originchain() ;
  const std::string& originchain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_originchain(Arg_&& arg, Args_... args);
  std::string* mutable_originchain();
  PROTOBUF_NODISCARD std::string* release_originchain();
  void set_allocated_originchain(std::string* value);

  private:
  const std::string& _internal_originchain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originchain(
      const std::string& value);
  std::string* _internal_mutable_originchain();

  public:
  // bytes destinationChain = 9;
  void clear_destinationchain() ;
  const std::string& destinationchain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destinationchain(Arg_&& arg, Args_... args);
  std::string* mutable_destinationchain();
  PROTOBUF_NODISCARD std::string* release_destinationchain();
  void set_allocated_destinationchain(std::string* value);

  private:
  const std::string& _internal_destinationchain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destinationchain(
      const std::string& value);
  std::string* _internal_mutable_destinationchain();

  public:
  // uint64 senderTransactionId = 1;
  void clear_sendertransactionid() ;
  ::uint64_t sendertransactionid() const;
  void set_sendertransactionid(::uint64_t value);

  private:
  ::uint64_t _internal_sendertransactionid() const;
  void _internal_set_sendertransactionid(::uint64_t value);

  public:
  // uint64 timestamp = 7;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.Penny)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr amount_;
    ::google::protobuf::internal::ArenaStringPtr sender_;
    ::google::protobuf::internal::ArenaStringPtr destination_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr originchain_;
    ::google::protobuf::internal::ArenaStringPtr destinationchain_;
    ::uint64_t sendertransactionid_;
    ::uint64_t timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class LogEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LogEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline LogEntry(const LogEntry& from) : LogEntry(nullptr, from) {}
  inline LogEntry(LogEntry&& from) noexcept
      : LogEntry(nullptr, std::move(from)) {}
  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
        &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(LogEntry& a, LogEntry& b) { a.Swap(&b); }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LogEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LogEntry& from) { LogEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LogEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.LogEntry"; }

 protected:
  explicit LogEntry(::google::protobuf::Arena* arena);
  LogEntry(::google::protobuf::Arena* arena, const LogEntry& from);
  LogEntry(::google::protobuf::Arena* arena, LogEntry&& from) noexcept
      : LogEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicsFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // repeated bytes topics = 1;
  int topics_size() const;
  private:
  int _internal_topics_size() const;

  public:
  void clear_topics() ;
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const void* value, std::size_t size);
  void set_topics(int index, absl::string_view value);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const void* value, std::size_t size);
  void add_topics(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_topics();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_topics();

  public:
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.LogEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> topics_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Log final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Log(
      ::google::protobuf::internal::ConstantInitialized);

  inline Log(const Log& from) : Log(nullptr, from) {}
  inline Log(Log&& from) noexcept
      : Log(nullptr, std::move(from)) {}
  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
        &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Log& a, Log& b) { a.Swap(&b); }
  inline void Swap(Log* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Log>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Log& from) { Log::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Log* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Log"; }

 protected:
  explicit Log(::google::protobuf::Arena* arena);
  Log(::google::protobuf::Arena* arena, const Log& from);
  Log(::google::protobuf::Arena* arena, Log&& from) noexcept
      : Log(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicsFieldNumber = 4,
    kAddressFieldNumber = 1,
    kDataFieldNumber = 5,
    kTransactionIdFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  // repeated bytes topics = 4;
  int topics_size() const;
  private:
  int _internal_topics_size() const;

  public:
  void clear_topics() ;
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const void* value, std::size_t size);
  void set_topics(int index, absl::string_view value);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const void* value, std::size_t size);
  void add_topics(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_topics();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_topics();

  public:
  // bytes address = 1;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // bytes data = 5;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // uint64 transactionId = 2;
  void clear_transactionid() ;
  ::uint64_t transactionid() const;
  void set_transactionid(::uint64_t value);

  private:
  ::uint64_t _internal_transactionid() const;
  void _internal_set_transactionid(::uint64_t value);

  public:
  // uint32 index = 3;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.Log)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> topics_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::uint64_t transactionid_;
    ::uint32_t index_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.BlockHeader) */ {
 public:
  inline BlockHeader() : BlockHeader(nullptr) {}
  ~BlockHeader() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockHeader(const BlockHeader& from) : BlockHeader(nullptr, from) {}
  inline BlockHeader(BlockHeader&& from) noexcept
      : BlockHeader(nullptr, std::move(from)) {}
  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
        &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BlockHeader& a, BlockHeader& b) { a.Swap(&b); }
  inline void Swap(BlockHeader* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockHeader* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BlockHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockHeader& from) { BlockHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlockHeader* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.BlockHeader"; }

 protected:
  explicit BlockHeader(::google::protobuf::Arena* arena);
  BlockHeader(::google::protobuf::Arena* arena, const BlockHeader& from);
  BlockHeader(::google::protobuf::Arena* arena, BlockHeader&& from) noexcept
      : BlockHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogHashesFieldNumber = 5,
    kPennyHashFieldNumber = 3,
    kReceiptHashFieldNumber = 4,
    kBalanceFieldNumber = 6,
    kHashFieldNumber = 7,
    kIdFieldNumber = 1,
    kEpochIdFieldNumber = 2,
    kTimestampFieldNumber = 8,
  };
  // repeated bytes logHashes = 5;
  int loghashes_size() const;
  private:
  int _internal_loghashes_size() const;

  public:
  void clear_loghashes() ;
  const std::string& loghashes(int index) const;
  std::string* mutable_loghashes(int index);
  void set_loghashes(int index, const std::string& value);
  void set_loghashes(int index, std::string&& value);
  void set_loghashes(int index, const char* value);
  void set_loghashes(int index, const void* value, std::size_t size);
  void set_loghashes(int index, absl::string_view value);
  std::string* add_loghashes();
  void add_loghashes(const std::string& value);
  void add_loghashes(std::string&& value);
  void add_loghashes(const char* value);
  void add_loghashes(const void* value, std::size_t size);
  void add_loghashes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& loghashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_loghashes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_loghashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_loghashes();

  public:
  // bytes pennyHash = 3;
  void clear_pennyhash() ;
  const std::string& pennyhash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pennyhash(Arg_&& arg, Args_... args);
  std::string* mutable_pennyhash();
  PROTOBUF_NODISCARD std::string* release_pennyhash();
  void set_allocated_pennyhash(std::string* value);

  private:
  const std::string& _internal_pennyhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pennyhash(
      const std::string& value);
  std::string* _internal_mutable_pennyhash();

  public:
  // bytes receiptHash = 4;
  void clear_receipthash() ;
  const std::string& receipthash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receipthash(Arg_&& arg, Args_... args);
  std::string* mutable_receipthash();
  PROTOBUF_NODISCARD std::string* release_receipthash();
  void set_allocated_receipthash(std::string* value);

  private:
  const std::string& _internal_receipthash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipthash(
      const std::string& value);
  std::string* _internal_mutable_receipthash();

  public:
  // bytes balance = 6;
  void clear_balance() ;
  const std::string& balance() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* value);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // bytes hash = 7;
  void clear_hash() ;
  const std::string& hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* value);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 epochId = 2;
  void clear_epochid() ;
  ::uint64_t epochid() const;
  void set_epochid(::uint64_t value);

  private:
  ::uint64_t _internal_epochid() const;
  void _internal_set_epochid(::uint64_t value);

  public:
  // uint64 timestamp = 8;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.BlockHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> loghashes_;
    ::google::protobuf::internal::ArenaStringPtr pennyhash_;
    ::google::protobuf::internal::ArenaStringPtr receipthash_;
    ::google::protobuf::internal::ArenaStringPtr balance_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::uint64_t id_;
    ::uint64_t epochid_;
    ::uint64_t timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Account final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  ~Account() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Account(
      ::google::protobuf::internal::ConstantInitialized);

  inline Account(const Account& from) : Account(nullptr, from) {}
  inline Account(Account&& from) noexcept
      : Account(nullptr, std::move(from)) {}
  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
        &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Account& a, Account& b) { a.Swap(&b); }
  inline void Swap(Account* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Account>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Account& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Account& from) { Account::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Account* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Account"; }

 protected:
  explicit Account(::google::protobuf::Arena* arena);
  Account(::google::protobuf::Arena* arena, const Account& from);
  Account(::google::protobuf::Arena* arena, Account&& from) noexcept
      : Account(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using State = Account_State;
  static constexpr State FINALIZED = Account_State_FINALIZED;
  static constexpr State PRECOMMIT = Account_State_PRECOMMIT;
  static constexpr State PREABORT = Account_State_PREABORT;
  static constexpr State CONFLICT = Account_State_CONFLICT;
  static inline bool State_IsValid(int value) {
    return Account_State_IsValid(value);
  }
  static constexpr State State_MIN = Account_State_State_MIN;
  static constexpr State State_MAX = Account_State_State_MAX;
  static constexpr int State_ARRAYSIZE = Account_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* State_descriptor() {
    return Account_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return Account_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return Account_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNonceFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // uint64 nonce = 1;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // .dataTypespb.Account.State state = 2;
  void clear_state() ;
  ::dataTypespb::Account_State state() const;
  void set_state(::dataTypespb::Account_State value);

  private:
  ::dataTypespb::Account_State _internal_state() const;
  void _internal_set_state(::dataTypespb::Account_State value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.Account)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t nonce_;
    int state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Receipt final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Receipt) */ {
 public:
  inline Receipt() : Receipt(nullptr) {}
  ~Receipt() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Receipt(
      ::google::protobuf::internal::ConstantInitialized);

  inline Receipt(const Receipt& from) : Receipt(nullptr, from) {}
  inline Receipt(Receipt&& from) noexcept
      : Receipt(nullptr, std::move(from)) {}
  inline Receipt& operator=(const Receipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Receipt& operator=(Receipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Receipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const Receipt* internal_default_instance() {
    return reinterpret_cast<const Receipt*>(
        &_Receipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Receipt& a, Receipt& b) { a.Swap(&b); }
  inline void Swap(Receipt* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Receipt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Receipt* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Receipt>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Receipt& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Receipt& from) { Receipt::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Receipt* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Receipt"; }

 protected:
  explicit Receipt(::google::protobuf::Arena* arena);
  Receipt(::google::protobuf::Arena* arena, const Receipt& from);
  Receipt(::google::protobuf::Arena* arena, Receipt&& from) noexcept
      : Receipt(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogsFieldNumber = 4,
    kContractAddressFieldNumber = 1,
    kGasUsedFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // repeated .dataTypespb.Log logs = 4;
  int logs_size() const;
  private:
  int _internal_logs_size() const;

  public:
  void clear_logs() ;
  ::dataTypespb::Log* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* mutable_logs();

  private:
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& _internal_logs() const;
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* _internal_mutable_logs();
  public:
  const ::dataTypespb::Log& logs(int index) const;
  ::dataTypespb::Log* add_logs();
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& logs() const;
  // bytes contractAddress = 1;
  void clear_contractaddress() ;
  const std::string& contractaddress() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contractaddress(Arg_&& arg, Args_... args);
  std::string* mutable_contractaddress();
  PROTOBUF_NODISCARD std::string* release_contractaddress();
  void set_allocated_contractaddress(std::string* value);

  private:
  const std::string& _internal_contractaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractaddress(
      const std::string& value);
  std::string* _internal_mutable_contractaddress();

  public:
  // uint64 gasUsed = 3;
  void clear_gasused() ;
  ::uint64_t gasused() const;
  void set_gasused(::uint64_t value);

  private:
  ::uint64_t _internal_gasused() const;
  void _internal_set_gasused(::uint64_t value);

  public:
  // bool status = 2;
  void clear_status() ;
  bool status() const;
  void set_status(bool value);

  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.Receipt)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dataTypespb::Log > logs_;
    ::google::protobuf::internal::ArenaStringPtr contractaddress_;
    ::uint64_t gasused_;
    bool status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class PennyWithSenderHash final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.PennyWithSenderHash) */ {
 public:
  inline PennyWithSenderHash() : PennyWithSenderHash(nullptr) {}
  ~PennyWithSenderHash() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PennyWithSenderHash(
      ::google::protobuf::internal::ConstantInitialized);

  inline PennyWithSenderHash(const PennyWithSenderHash& from) : PennyWithSenderHash(nullptr, from) {}
  inline PennyWithSenderHash(PennyWithSenderHash&& from) noexcept
      : PennyWithSenderHash(nullptr, std::move(from)) {}
  inline PennyWithSenderHash& operator=(const PennyWithSenderHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline PennyWithSenderHash& operator=(PennyWithSenderHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PennyWithSenderHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const PennyWithSenderHash* internal_default_instance() {
    return reinterpret_cast<const PennyWithSenderHash*>(
        &_PennyWithSenderHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PennyWithSenderHash& a, PennyWithSenderHash& b) { a.Swap(&b); }
  inline void Swap(PennyWithSenderHash* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PennyWithSenderHash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PennyWithSenderHash* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PennyWithSenderHash>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PennyWithSenderHash& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PennyWithSenderHash& from) { PennyWithSenderHash::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PennyWithSenderHash* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.PennyWithSenderHash"; }

 protected:
  explicit PennyWithSenderHash(::google::protobuf::Arena* arena);
  PennyWithSenderHash(::google::protobuf::Arena* arena, const PennyWithSenderHash& from);
  PennyWithSenderHash(::google::protobuf::Arena* arena, PennyWithSenderHash&& from) noexcept
      : PennyWithSenderHash(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSenderBlockHashFieldNumber = 2,
    kPennyFieldNumber = 1,
    kSenderEpochIdFieldNumber = 3,
  };
  // bytes senderBlockHash = 2;
  void clear_senderblockhash() ;
  const std::string& senderblockhash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_senderblockhash(Arg_&& arg, Args_... args);
  std::string* mutable_senderblockhash();
  PROTOBUF_NODISCARD std::string* release_senderblockhash();
  void set_allocated_senderblockhash(std::string* value);

  private:
  const std::string& _internal_senderblockhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderblockhash(
      const std::string& value);
  std::string* _internal_mutable_senderblockhash();

  public:
  // .dataTypespb.Penny penny = 1;
  bool has_penny() const;
  void clear_penny() ;
  const ::dataTypespb::Penny& penny() const;
  PROTOBUF_NODISCARD ::dataTypespb::Penny* release_penny();
  ::dataTypespb::Penny* mutable_penny();
  void set_allocated_penny(::dataTypespb::Penny* value);
  void unsafe_arena_set_allocated_penny(::dataTypespb::Penny* value);
  ::dataTypespb::Penny* unsafe_arena_release_penny();

  private:
  const ::dataTypespb::Penny& _internal_penny() const;
  ::dataTypespb::Penny* _internal_mutable_penny();

  public:
  // uint64 senderEpochId = 3;
  void clear_senderepochid() ;
  ::uint64_t senderepochid() const;
  void set_senderepochid(::uint64_t value);

  private:
  ::uint64_t _internal_senderepochid() const;
  void _internal_set_senderepochid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.PennyWithSenderHash)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr senderblockhash_;
    ::dataTypespb::Penny* penny_;
    ::uint64_t senderepochid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Logs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Logs) */ {
 public:
  inline Logs() : Logs(nullptr) {}
  ~Logs() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Logs(
      ::google::protobuf::internal::ConstantInitialized);

  inline Logs(const Logs& from) : Logs(nullptr, from) {}
  inline Logs(Logs&& from) noexcept
      : Logs(nullptr, std::move(from)) {}
  inline Logs& operator=(const Logs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logs& operator=(Logs&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Logs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Logs* internal_default_instance() {
    return reinterpret_cast<const Logs*>(
        &_Logs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Logs& a, Logs& b) { a.Swap(&b); }
  inline void Swap(Logs* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Logs* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Logs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Logs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Logs& from) { Logs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Logs* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Logs"; }

 protected:
  explicit Logs(::google::protobuf::Arena* arena);
  Logs(::google::protobuf::Arena* arena, const Logs& from);
  Logs(::google::protobuf::Arena* arena, Logs&& from) noexcept
      : Logs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .dataTypespb.Log list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;

  public:
  void clear_list() ;
  ::dataTypespb::Log* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* mutable_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& _internal_list() const;
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* _internal_mutable_list();
  public:
  const ::dataTypespb::Log& list(int index) const;
  ::dataTypespb::Log* add_list();
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& list() const;
  // @@protoc_insertion_point(class_scope:dataTypespb.Logs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dataTypespb::Log > list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Receipts final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Receipts) */ {
 public:
  inline Receipts() : Receipts(nullptr) {}
  ~Receipts() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Receipts(
      ::google::protobuf::internal::ConstantInitialized);

  inline Receipts(const Receipts& from) : Receipts(nullptr, from) {}
  inline Receipts(Receipts&& from) noexcept
      : Receipts(nullptr, std::move(from)) {}
  inline Receipts& operator=(const Receipts& from) {
    CopyFrom(from);
    return *this;
  }
  inline Receipts& operator=(Receipts&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Receipts& default_instance() {
    return *internal_default_instance();
  }
  static inline const Receipts* internal_default_instance() {
    return reinterpret_cast<const Receipts*>(
        &_Receipts_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Receipts& a, Receipts& b) { a.Swap(&b); }
  inline void Swap(Receipts* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Receipts* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Receipts* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Receipts>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Receipts& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Receipts& from) { Receipts::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Receipts* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Receipts"; }

 protected:
  explicit Receipts(::google::protobuf::Arena* arena);
  Receipts(::google::protobuf::Arena* arena, const Receipts& from);
  Receipts(::google::protobuf::Arena* arena, Receipts&& from) noexcept
      : Receipts(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .dataTypespb.Receipt list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;

  public:
  void clear_list() ;
  ::dataTypespb::Receipt* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>* mutable_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>& _internal_list() const;
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>* _internal_mutable_list();
  public:
  const ::dataTypespb::Receipt& list(int index) const;
  ::dataTypespb::Receipt* add_list();
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>& list() const;
  // @@protoc_insertion_point(class_scope:dataTypespb.Receipts)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dataTypespb::Receipt > list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Block final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Block(
      ::google::protobuf::internal::ConstantInitialized);

  inline Block(const Block& from) : Block(nullptr, from) {}
  inline Block(Block&& from) noexcept
      : Block(nullptr, std::move(from)) {}
  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
        &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Block& a, Block& b) { a.Swap(&b); }
  inline void Swap(Block* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Block>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Block& from) { Block::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Block* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Block"; }

 protected:
  explicit Block(::google::protobuf::Arena* arena);
  Block(::google::protobuf::Arena* arena, const Block& from);
  Block(::google::protobuf::Arena* arena, Block&& from) noexcept
      : Block(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogsFieldNumber = 5,
    kBalanceFieldNumber = 6,
    kHashFieldNumber = 7,
    kPennyFieldNumber = 3,
    kReceiptFieldNumber = 4,
    kIdFieldNumber = 1,
    kEpochIdFieldNumber = 2,
    kTimeStampFieldNumber = 8,
  };
  // repeated .dataTypespb.Log logs = 5;
  int logs_size() const;
  private:
  int _internal_logs_size() const;

  public:
  void clear_logs() ;
  ::dataTypespb::Log* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* mutable_logs();

  private:
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& _internal_logs() const;
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* _internal_mutable_logs();
  public:
  const ::dataTypespb::Log& logs(int index) const;
  ::dataTypespb::Log* add_logs();
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& logs() const;
  // bytes balance = 6;
  void clear_balance() ;
  const std::string& balance() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* value);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // bytes hash = 7;
  void clear_hash() ;
  const std::string& hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* value);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // .dataTypespb.Penny penny = 3;
  bool has_penny() const;
  void clear_penny() ;
  const ::dataTypespb::Penny& penny() const;
  PROTOBUF_NODISCARD ::dataTypespb::Penny* release_penny();
  ::dataTypespb::Penny* mutable_penny();
  void set_allocated_penny(::dataTypespb::Penny* value);
  void unsafe_arena_set_allocated_penny(::dataTypespb::Penny* value);
  ::dataTypespb::Penny* unsafe_arena_release_penny();

  private:
  const ::dataTypespb::Penny& _internal_penny() const;
  ::dataTypespb::Penny* _internal_mutable_penny();

  public:
  // .dataTypespb.Receipt receipt = 4;
  bool has_receipt() const;
  void clear_receipt() ;
  const ::dataTypespb::Receipt& receipt() const;
  PROTOBUF_NODISCARD ::dataTypespb::Receipt* release_receipt();
  ::dataTypespb::Receipt* mutable_receipt();
  void set_allocated_receipt(::dataTypespb::Receipt* value);
  void unsafe_arena_set_allocated_receipt(::dataTypespb::Receipt* value);
  ::dataTypespb::Receipt* unsafe_arena_release_receipt();

  private:
  const ::dataTypespb::Receipt& _internal_receipt() const;
  ::dataTypespb::Receipt* _internal_mutable_receipt();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 epochId = 2;
  void clear_epochid() ;
  ::uint64_t epochid() const;
  void set_epochid(::uint64_t value);

  private:
  ::uint64_t _internal_epochid() const;
  void _internal_set_epochid(::uint64_t value);

  public:
  // uint64 timeStamp = 8;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dataTypespb.Block)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dataTypespb::Log > logs_;
    ::google::protobuf::internal::ArenaStringPtr balance_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::dataTypespb::Penny* penny_;
    ::dataTypespb::Receipt* receipt_;
    ::uint64_t id_;
    ::uint64_t epochid_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};
// -------------------------------------------------------------------

class Blocks final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dataTypespb.Blocks) */ {
 public:
  inline Blocks() : Blocks(nullptr) {}
  ~Blocks() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Blocks(
      ::google::protobuf::internal::ConstantInitialized);

  inline Blocks(const Blocks& from) : Blocks(nullptr, from) {}
  inline Blocks(Blocks&& from) noexcept
      : Blocks(nullptr, std::move(from)) {}
  inline Blocks& operator=(const Blocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blocks& operator=(Blocks&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blocks& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blocks* internal_default_instance() {
    return reinterpret_cast<const Blocks*>(
        &_Blocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Blocks& a, Blocks& b) { a.Swap(&b); }
  inline void Swap(Blocks* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blocks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Blocks* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Blocks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Blocks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Blocks& from) { Blocks::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Blocks* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dataTypespb.Blocks"; }

 protected:
  explicit Blocks(::google::protobuf::Arena* arena);
  Blocks(::google::protobuf::Arena* arena, const Blocks& from);
  Blocks(::google::protobuf::Arena* arena, Blocks&& from) noexcept
      : Blocks(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .dataTypespb.Block list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;

  public:
  void clear_list() ;
  ::dataTypespb::Block* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>* mutable_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>& _internal_list() const;
  ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>* _internal_mutable_list();
  public:
  const ::dataTypespb::Block& list(int index) const;
  ::dataTypespb::Block* add_list();
  const ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>& list() const;
  // @@protoc_insertion_point(class_scope:dataTypespb.Blocks)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dataTypespb::Block > list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataTypespb_2fdataTypes_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Account

// uint64 nonce = 1;
inline void Account::clear_nonce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t Account::nonce() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Account.nonce)
  return _internal_nonce();
}
inline void Account::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Account.nonce)
}
inline ::uint64_t Account::_internal_nonce() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nonce_;
}
inline void Account::_internal_set_nonce(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nonce_ = value;
}

// .dataTypespb.Account.State state = 2;
inline void Account::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::dataTypespb::Account_State Account::state() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Account.state)
  return _internal_state();
}
inline void Account::set_state(::dataTypespb::Account_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Account.state)
}
inline ::dataTypespb::Account_State Account::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::dataTypespb::Account_State>(_impl_.state_);
}
inline void Account::_internal_set_state(::dataTypespb::Account_State value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// Block

// uint64 id = 1;
inline void Block::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Block::id() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.id)
  return _internal_id();
}
inline void Block::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Block.id)
}
inline ::uint64_t Block::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Block::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// uint64 epochId = 2;
inline void Block::clear_epochid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epochid_ = ::uint64_t{0u};
}
inline ::uint64_t Block::epochid() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.epochId)
  return _internal_epochid();
}
inline void Block::set_epochid(::uint64_t value) {
  _internal_set_epochid(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Block.epochId)
}
inline ::uint64_t Block::_internal_epochid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epochid_;
}
inline void Block::_internal_set_epochid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epochid_ = value;
}

// .dataTypespb.Penny penny = 3;
inline bool Block::has_penny() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.penny_ != nullptr);
  return value;
}
inline void Block::clear_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.penny_ != nullptr) _impl_.penny_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dataTypespb::Penny& Block::_internal_penny() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dataTypespb::Penny* p = _impl_.penny_;
  return p != nullptr ? *p : reinterpret_cast<const ::dataTypespb::Penny&>(::dataTypespb::_Penny_default_instance_);
}
inline const ::dataTypespb::Penny& Block::penny() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.penny)
  return _internal_penny();
}
inline void Block::unsafe_arena_set_allocated_penny(::dataTypespb::Penny* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.penny_);
  }
  _impl_.penny_ = reinterpret_cast<::dataTypespb::Penny*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dataTypespb.Block.penny)
}
inline ::dataTypespb::Penny* Block::release_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dataTypespb::Penny* released = _impl_.penny_;
  _impl_.penny_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dataTypespb::Penny* Block::unsafe_arena_release_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Block.penny)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dataTypespb::Penny* temp = _impl_.penny_;
  _impl_.penny_ = nullptr;
  return temp;
}
inline ::dataTypespb::Penny* Block::_internal_mutable_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.penny_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dataTypespb::Penny>(GetArena());
    _impl_.penny_ = reinterpret_cast<::dataTypespb::Penny*>(p);
  }
  return _impl_.penny_;
}
inline ::dataTypespb::Penny* Block::mutable_penny() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dataTypespb::Penny* _msg = _internal_mutable_penny();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Block.penny)
  return _msg;
}
inline void Block::set_allocated_penny(::dataTypespb::Penny* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.penny_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.penny_ = reinterpret_cast<::dataTypespb::Penny*>(value);
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Block.penny)
}

// .dataTypespb.Receipt receipt = 4;
inline bool Block::has_receipt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receipt_ != nullptr);
  return value;
}
inline void Block::clear_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.receipt_ != nullptr) _impl_.receipt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dataTypespb::Receipt& Block::_internal_receipt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dataTypespb::Receipt* p = _impl_.receipt_;
  return p != nullptr ? *p : reinterpret_cast<const ::dataTypespb::Receipt&>(::dataTypespb::_Receipt_default_instance_);
}
inline const ::dataTypespb::Receipt& Block::receipt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.receipt)
  return _internal_receipt();
}
inline void Block::unsafe_arena_set_allocated_receipt(::dataTypespb::Receipt* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receipt_);
  }
  _impl_.receipt_ = reinterpret_cast<::dataTypespb::Receipt*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dataTypespb.Block.receipt)
}
inline ::dataTypespb::Receipt* Block::release_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dataTypespb::Receipt* released = _impl_.receipt_;
  _impl_.receipt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dataTypespb::Receipt* Block::unsafe_arena_release_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Block.receipt)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dataTypespb::Receipt* temp = _impl_.receipt_;
  _impl_.receipt_ = nullptr;
  return temp;
}
inline ::dataTypespb::Receipt* Block::_internal_mutable_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.receipt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dataTypespb::Receipt>(GetArena());
    _impl_.receipt_ = reinterpret_cast<::dataTypespb::Receipt*>(p);
  }
  return _impl_.receipt_;
}
inline ::dataTypespb::Receipt* Block::mutable_receipt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dataTypespb::Receipt* _msg = _internal_mutable_receipt();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Block.receipt)
  return _msg;
}
inline void Block::set_allocated_receipt(::dataTypespb::Receipt* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.receipt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.receipt_ = reinterpret_cast<::dataTypespb::Receipt*>(value);
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Block.receipt)
}

// repeated .dataTypespb.Log logs = 5;
inline int Block::_internal_logs_size() const {
  return _internal_logs().size();
}
inline int Block::logs_size() const {
  return _internal_logs_size();
}
inline void Block::clear_logs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.logs_.Clear();
}
inline ::dataTypespb::Log* Block::mutable_logs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.Block.logs)
  return _internal_mutable_logs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* Block::mutable_logs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.Block.logs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_logs();
}
inline const ::dataTypespb::Log& Block::logs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.logs)
  return _internal_logs().Get(index);
}
inline ::dataTypespb::Log* Block::add_logs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dataTypespb::Log* _add = _internal_mutable_logs()->Add();
  // @@protoc_insertion_point(field_add:dataTypespb.Block.logs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& Block::logs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.Block.logs)
  return _internal_logs();
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>&
Block::_internal_logs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.logs_;
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>*
Block::_internal_mutable_logs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.logs_;
}

// bytes balance = 6;
inline void Block::clear_balance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& Block::balance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Block::set_balance(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Block.balance)
}
inline std::string* Block::mutable_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Block.balance)
  return _s;
}
inline const std::string& Block::_internal_balance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.balance_.Get();
}
inline void Block::_internal_set_balance(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.Set(value, GetArena());
}
inline std::string* Block::_internal_mutable_balance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.balance_.Mutable( GetArena());
}
inline std::string* Block::release_balance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Block.balance)
  return _impl_.balance_.Release();
}
inline void Block::set_allocated_balance(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_.IsDefault()) {
          _impl_.balance_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Block.balance)
}

// bytes hash = 7;
inline void Block::clear_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& Block::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Block::set_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Block.hash)
}
inline std::string* Block::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Block.hash)
  return _s;
}
inline const std::string& Block::_internal_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hash_.Get();
}
inline void Block::_internal_set_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.Set(value, GetArena());
}
inline std::string* Block::_internal_mutable_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.hash_.Mutable( GetArena());
}
inline std::string* Block::release_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Block.hash)
  return _impl_.hash_.Release();
}
inline void Block::set_allocated_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Block.hash)
}

// uint64 timeStamp = 8;
inline void Block::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t Block::timestamp() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Block.timeStamp)
  return _internal_timestamp();
}
inline void Block::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Block.timeStamp)
}
inline ::uint64_t Block::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void Block::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// Blocks

// repeated .dataTypespb.Block list = 1;
inline int Blocks::_internal_list_size() const {
  return _internal_list().size();
}
inline int Blocks::list_size() const {
  return _internal_list_size();
}
inline void Blocks::clear_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.list_.Clear();
}
inline ::dataTypespb::Block* Blocks::mutable_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.Blocks.list)
  return _internal_mutable_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>* Blocks::mutable_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.Blocks.list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_list();
}
inline const ::dataTypespb::Block& Blocks::list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Blocks.list)
  return _internal_list().Get(index);
}
inline ::dataTypespb::Block* Blocks::add_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dataTypespb::Block* _add = _internal_mutable_list()->Add();
  // @@protoc_insertion_point(field_add:dataTypespb.Blocks.list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>& Blocks::list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.Blocks.list)
  return _internal_list();
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>&
Blocks::_internal_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.list_;
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Block>*
Blocks::_internal_mutable_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.list_;
}

// -------------------------------------------------------------------

// BlockHeader

// uint64 id = 1;
inline void BlockHeader::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t BlockHeader::id() const {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.id)
  return _internal_id();
}
inline void BlockHeader::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.id)
}
inline ::uint64_t BlockHeader::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void BlockHeader::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// uint64 epochId = 2;
inline void BlockHeader::clear_epochid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epochid_ = ::uint64_t{0u};
}
inline ::uint64_t BlockHeader::epochid() const {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.epochId)
  return _internal_epochid();
}
inline void BlockHeader::set_epochid(::uint64_t value) {
  _internal_set_epochid(value);
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.epochId)
}
inline ::uint64_t BlockHeader::_internal_epochid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epochid_;
}
inline void BlockHeader::_internal_set_epochid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epochid_ = value;
}

// bytes pennyHash = 3;
inline void BlockHeader::clear_pennyhash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pennyhash_.ClearToEmpty();
}
inline const std::string& BlockHeader::pennyhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.pennyHash)
  return _internal_pennyhash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockHeader::set_pennyhash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pennyhash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.pennyHash)
}
inline std::string* BlockHeader::mutable_pennyhash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pennyhash();
  // @@protoc_insertion_point(field_mutable:dataTypespb.BlockHeader.pennyHash)
  return _s;
}
inline const std::string& BlockHeader::_internal_pennyhash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pennyhash_.Get();
}
inline void BlockHeader::_internal_set_pennyhash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pennyhash_.Set(value, GetArena());
}
inline std::string* BlockHeader::_internal_mutable_pennyhash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.pennyhash_.Mutable( GetArena());
}
inline std::string* BlockHeader::release_pennyhash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.BlockHeader.pennyHash)
  return _impl_.pennyhash_.Release();
}
inline void BlockHeader::set_allocated_pennyhash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pennyhash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pennyhash_.IsDefault()) {
          _impl_.pennyhash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.BlockHeader.pennyHash)
}

// bytes receiptHash = 4;
inline void BlockHeader::clear_receipthash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receipthash_.ClearToEmpty();
}
inline const std::string& BlockHeader::receipthash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.receiptHash)
  return _internal_receipthash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockHeader::set_receipthash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receipthash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.receiptHash)
}
inline std::string* BlockHeader::mutable_receipthash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_receipthash();
  // @@protoc_insertion_point(field_mutable:dataTypespb.BlockHeader.receiptHash)
  return _s;
}
inline const std::string& BlockHeader::_internal_receipthash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.receipthash_.Get();
}
inline void BlockHeader::_internal_set_receipthash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receipthash_.Set(value, GetArena());
}
inline std::string* BlockHeader::_internal_mutable_receipthash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.receipthash_.Mutable( GetArena());
}
inline std::string* BlockHeader::release_receipthash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.BlockHeader.receiptHash)
  return _impl_.receipthash_.Release();
}
inline void BlockHeader::set_allocated_receipthash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receipthash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receipthash_.IsDefault()) {
          _impl_.receipthash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.BlockHeader.receiptHash)
}

// repeated bytes logHashes = 5;
inline int BlockHeader::_internal_loghashes_size() const {
  return _internal_loghashes().size();
}
inline int BlockHeader::loghashes_size() const {
  return _internal_loghashes_size();
}
inline void BlockHeader::clear_loghashes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loghashes_.Clear();
}
inline std::string* BlockHeader::add_loghashes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_loghashes()->Add();
  // @@protoc_insertion_point(field_add_mutable:dataTypespb.BlockHeader.logHashes)
  return _s;
}
inline const std::string& BlockHeader::loghashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.logHashes)
  return _internal_loghashes().Get(index);
}
inline std::string* BlockHeader::mutable_loghashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.BlockHeader.logHashes)
  return _internal_mutable_loghashes()->Mutable(index);
}
inline void BlockHeader::set_loghashes(int index, const std::string& value) {
  _internal_mutable_loghashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::set_loghashes(int index, std::string&& value) {
  _internal_mutable_loghashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::set_loghashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_loghashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::set_loghashes(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_loghashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::set_loghashes(int index, absl::string_view value) {
  _internal_mutable_loghashes()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::add_loghashes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::add_loghashes(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::add_loghashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::add_loghashes(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dataTypespb.BlockHeader.logHashes)
}
inline void BlockHeader::add_loghashes(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:dataTypespb.BlockHeader.logHashes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlockHeader::loghashes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.BlockHeader.logHashes)
  return _internal_loghashes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlockHeader::mutable_loghashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.BlockHeader.logHashes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_loghashes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlockHeader::_internal_loghashes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loghashes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlockHeader::_internal_mutable_loghashes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.loghashes_;
}

// bytes balance = 6;
inline void BlockHeader::clear_balance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& BlockHeader::balance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockHeader::set_balance(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.balance)
}
inline std::string* BlockHeader::mutable_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:dataTypespb.BlockHeader.balance)
  return _s;
}
inline const std::string& BlockHeader::_internal_balance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.balance_.Get();
}
inline void BlockHeader::_internal_set_balance(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.Set(value, GetArena());
}
inline std::string* BlockHeader::_internal_mutable_balance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.balance_.Mutable( GetArena());
}
inline std::string* BlockHeader::release_balance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.BlockHeader.balance)
  return _impl_.balance_.Release();
}
inline void BlockHeader::set_allocated_balance(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balance_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_.IsDefault()) {
          _impl_.balance_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.BlockHeader.balance)
}

// bytes hash = 7;
inline void BlockHeader::clear_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& BlockHeader::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockHeader::set_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.hash)
}
inline std::string* BlockHeader::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:dataTypespb.BlockHeader.hash)
  return _s;
}
inline const std::string& BlockHeader::_internal_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hash_.Get();
}
inline void BlockHeader::_internal_set_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.Set(value, GetArena());
}
inline std::string* BlockHeader::_internal_mutable_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.hash_.Mutable( GetArena());
}
inline std::string* BlockHeader::release_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.BlockHeader.hash)
  return _impl_.hash_.Release();
}
inline void BlockHeader::set_allocated_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.BlockHeader.hash)
}

// uint64 timestamp = 8;
inline void BlockHeader::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t BlockHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:dataTypespb.BlockHeader.timestamp)
  return _internal_timestamp();
}
inline void BlockHeader::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:dataTypespb.BlockHeader.timestamp)
}
inline ::uint64_t BlockHeader::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void BlockHeader::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// Penny

// uint64 senderTransactionId = 1;
inline void Penny::clear_sendertransactionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sendertransactionid_ = ::uint64_t{0u};
}
inline ::uint64_t Penny::sendertransactionid() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.senderTransactionId)
  return _internal_sendertransactionid();
}
inline void Penny::set_sendertransactionid(::uint64_t value) {
  _internal_set_sendertransactionid(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.senderTransactionId)
}
inline ::uint64_t Penny::_internal_sendertransactionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sendertransactionid_;
}
inline void Penny::_internal_set_sendertransactionid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sendertransactionid_ = value;
}

// bytes amount = 3;
inline void Penny::clear_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& Penny::amount() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Penny::set_amount(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.amount_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.amount)
}
inline std::string* Penny::mutable_amount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Penny.amount)
  return _s;
}
inline const std::string& Penny::_internal_amount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.amount_.Get();
}
inline void Penny::_internal_set_amount(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.amount_.Set(value, GetArena());
}
inline std::string* Penny::_internal_mutable_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.amount_.Mutable( GetArena());
}
inline std::string* Penny::release_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Penny.amount)
  return _impl_.amount_.Release();
}
inline void Penny::set_allocated_amount(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.amount_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Penny.amount)
}

// bytes sender = 4;
inline void Penny::clear_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& Penny::sender() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Penny::set_sender(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.sender)
}
inline std::string* Penny::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Penny.sender)
  return _s;
}
inline const std::string& Penny::_internal_sender() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_.Get();
}
inline void Penny::_internal_set_sender(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.Set(value, GetArena());
}
inline std::string* Penny::_internal_mutable_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.sender_.Mutable( GetArena());
}
inline std::string* Penny::release_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Penny.sender)
  return _impl_.sender_.Release();
}
inline void Penny::set_allocated_sender(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Penny.sender)
}

// bytes destination = 5;
inline void Penny::clear_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& Penny::destination() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Penny::set_destination(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.destination)
}
inline std::string* Penny::mutable_destination() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Penny.destination)
  return _s;
}
inline const std::string& Penny::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destination_.Get();
}
inline void Penny::_internal_set_destination(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_.Set(value, GetArena());
}
inline std::string* Penny::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.destination_.Mutable( GetArena());
}
inline std::string* Penny::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Penny.destination)
  return _impl_.destination_.Release();
}
inline void Penny::set_allocated_destination(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Penny.destination)
}

// bytes data = 6;
inline void Penny::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Penny::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Penny::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.data)
}
inline std::string* Penny::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Penny.data)
  return _s;
}
inline const std::string& Penny::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void Penny::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Penny::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Penny::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Penny.data)
  return _impl_.data_.Release();
}
inline void Penny::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Penny.data)
}

// uint64 timestamp = 7;
inline void Penny::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t Penny::timestamp() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.timestamp)
  return _internal_timestamp();
}
inline void Penny::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.timestamp)
}
inline ::uint64_t Penny::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void Penny::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = value;
}

// bytes originChain = 8;
inline void Penny::clear_originchain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.originchain_.ClearToEmpty();
}
inline const std::string& Penny::originchain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.originChain)
  return _internal_originchain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Penny::set_originchain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.originchain_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.originChain)
}
inline std::string* Penny::mutable_originchain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_originchain();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Penny.originChain)
  return _s;
}
inline const std::string& Penny::_internal_originchain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.originchain_.Get();
}
inline void Penny::_internal_set_originchain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.originchain_.Set(value, GetArena());
}
inline std::string* Penny::_internal_mutable_originchain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.originchain_.Mutable( GetArena());
}
inline std::string* Penny::release_originchain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Penny.originChain)
  return _impl_.originchain_.Release();
}
inline void Penny::set_allocated_originchain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.originchain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.originchain_.IsDefault()) {
          _impl_.originchain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Penny.originChain)
}

// bytes destinationChain = 9;
inline void Penny::clear_destinationchain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destinationchain_.ClearToEmpty();
}
inline const std::string& Penny::destinationchain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Penny.destinationChain)
  return _internal_destinationchain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Penny::set_destinationchain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destinationchain_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Penny.destinationChain)
}
inline std::string* Penny::mutable_destinationchain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_destinationchain();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Penny.destinationChain)
  return _s;
}
inline const std::string& Penny::_internal_destinationchain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destinationchain_.Get();
}
inline void Penny::_internal_set_destinationchain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destinationchain_.Set(value, GetArena());
}
inline std::string* Penny::_internal_mutable_destinationchain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.destinationchain_.Mutable( GetArena());
}
inline std::string* Penny::release_destinationchain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Penny.destinationChain)
  return _impl_.destinationchain_.Release();
}
inline void Penny::set_allocated_destinationchain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destinationchain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destinationchain_.IsDefault()) {
          _impl_.destinationchain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Penny.destinationChain)
}

// -------------------------------------------------------------------

// PennyWithSenderHash

// .dataTypespb.Penny penny = 1;
inline bool PennyWithSenderHash::has_penny() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.penny_ != nullptr);
  return value;
}
inline void PennyWithSenderHash::clear_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.penny_ != nullptr) _impl_.penny_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dataTypespb::Penny& PennyWithSenderHash::_internal_penny() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dataTypespb::Penny* p = _impl_.penny_;
  return p != nullptr ? *p : reinterpret_cast<const ::dataTypespb::Penny&>(::dataTypespb::_Penny_default_instance_);
}
inline const ::dataTypespb::Penny& PennyWithSenderHash::penny() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.PennyWithSenderHash.penny)
  return _internal_penny();
}
inline void PennyWithSenderHash::unsafe_arena_set_allocated_penny(::dataTypespb::Penny* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.penny_);
  }
  _impl_.penny_ = reinterpret_cast<::dataTypespb::Penny*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dataTypespb.PennyWithSenderHash.penny)
}
inline ::dataTypespb::Penny* PennyWithSenderHash::release_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dataTypespb::Penny* released = _impl_.penny_;
  _impl_.penny_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dataTypespb::Penny* PennyWithSenderHash::unsafe_arena_release_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.PennyWithSenderHash.penny)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dataTypespb::Penny* temp = _impl_.penny_;
  _impl_.penny_ = nullptr;
  return temp;
}
inline ::dataTypespb::Penny* PennyWithSenderHash::_internal_mutable_penny() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.penny_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dataTypespb::Penny>(GetArena());
    _impl_.penny_ = reinterpret_cast<::dataTypespb::Penny*>(p);
  }
  return _impl_.penny_;
}
inline ::dataTypespb::Penny* PennyWithSenderHash::mutable_penny() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dataTypespb::Penny* _msg = _internal_mutable_penny();
  // @@protoc_insertion_point(field_mutable:dataTypespb.PennyWithSenderHash.penny)
  return _msg;
}
inline void PennyWithSenderHash::set_allocated_penny(::dataTypespb::Penny* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.penny_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.penny_ = reinterpret_cast<::dataTypespb::Penny*>(value);
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.PennyWithSenderHash.penny)
}

// bytes senderBlockHash = 2;
inline void PennyWithSenderHash::clear_senderblockhash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.senderblockhash_.ClearToEmpty();
}
inline const std::string& PennyWithSenderHash::senderblockhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.PennyWithSenderHash.senderBlockHash)
  return _internal_senderblockhash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PennyWithSenderHash::set_senderblockhash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.senderblockhash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.PennyWithSenderHash.senderBlockHash)
}
inline std::string* PennyWithSenderHash::mutable_senderblockhash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_senderblockhash();
  // @@protoc_insertion_point(field_mutable:dataTypespb.PennyWithSenderHash.senderBlockHash)
  return _s;
}
inline const std::string& PennyWithSenderHash::_internal_senderblockhash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.senderblockhash_.Get();
}
inline void PennyWithSenderHash::_internal_set_senderblockhash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.senderblockhash_.Set(value, GetArena());
}
inline std::string* PennyWithSenderHash::_internal_mutable_senderblockhash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.senderblockhash_.Mutable( GetArena());
}
inline std::string* PennyWithSenderHash::release_senderblockhash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.PennyWithSenderHash.senderBlockHash)
  return _impl_.senderblockhash_.Release();
}
inline void PennyWithSenderHash::set_allocated_senderblockhash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.senderblockhash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.senderblockhash_.IsDefault()) {
          _impl_.senderblockhash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.PennyWithSenderHash.senderBlockHash)
}

// uint64 senderEpochId = 3;
inline void PennyWithSenderHash::clear_senderepochid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.senderepochid_ = ::uint64_t{0u};
}
inline ::uint64_t PennyWithSenderHash::senderepochid() const {
  // @@protoc_insertion_point(field_get:dataTypespb.PennyWithSenderHash.senderEpochId)
  return _internal_senderepochid();
}
inline void PennyWithSenderHash::set_senderepochid(::uint64_t value) {
  _internal_set_senderepochid(value);
  // @@protoc_insertion_point(field_set:dataTypespb.PennyWithSenderHash.senderEpochId)
}
inline ::uint64_t PennyWithSenderHash::_internal_senderepochid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.senderepochid_;
}
inline void PennyWithSenderHash::_internal_set_senderepochid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.senderepochid_ = value;
}

// -------------------------------------------------------------------

// Log

// bytes address = 1;
inline void Log::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Log::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Log.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Log::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Log.address)
}
inline std::string* Log::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Log.address)
  return _s;
}
inline const std::string& Log::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Log::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Log::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Log::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Log.address)
  return _impl_.address_.Release();
}
inline void Log::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Log.address)
}

// uint64 transactionId = 2;
inline void Log::clear_transactionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transactionid_ = ::uint64_t{0u};
}
inline ::uint64_t Log::transactionid() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Log.transactionId)
  return _internal_transactionid();
}
inline void Log::set_transactionid(::uint64_t value) {
  _internal_set_transactionid(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Log.transactionId)
}
inline ::uint64_t Log::_internal_transactionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transactionid_;
}
inline void Log::_internal_set_transactionid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transactionid_ = value;
}

// uint32 index = 3;
inline void Log::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0u;
}
inline ::uint32_t Log::index() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Log.index)
  return _internal_index();
}
inline void Log::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Log.index)
}
inline ::uint32_t Log::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void Log::_internal_set_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = value;
}

// repeated bytes topics = 4;
inline int Log::_internal_topics_size() const {
  return _internal_topics().size();
}
inline int Log::topics_size() const {
  return _internal_topics_size();
}
inline void Log::clear_topics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_.Clear();
}
inline std::string* Log::add_topics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_topics()->Add();
  // @@protoc_insertion_point(field_add_mutable:dataTypespb.Log.topics)
  return _s;
}
inline const std::string& Log::topics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Log.topics)
  return _internal_topics().Get(index);
}
inline std::string* Log::mutable_topics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.Log.topics)
  return _internal_mutable_topics()->Mutable(index);
}
inline void Log::set_topics(int index, const std::string& value) {
  _internal_mutable_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Log.topics)
}
inline void Log::set_topics(int index, std::string&& value) {
  _internal_mutable_topics()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dataTypespb.Log.topics)
}
inline void Log::set_topics(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dataTypespb.Log.topics)
}
inline void Log::set_topics(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_topics()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dataTypespb.Log.topics)
}
inline void Log::set_topics(int index, absl::string_view value) {
  _internal_mutable_topics()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:dataTypespb.Log.topics)
}
inline void Log::add_topics(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:dataTypespb.Log.topics)
}
inline void Log::add_topics(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:dataTypespb.Log.topics)
}
inline void Log::add_topics(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dataTypespb.Log.topics)
}
inline void Log::add_topics(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dataTypespb.Log.topics)
}
inline void Log::add_topics(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:dataTypespb.Log.topics)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Log::topics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.Log.topics)
  return _internal_topics();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Log::mutable_topics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.Log.topics)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_topics();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Log::_internal_topics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Log::_internal_mutable_topics() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.topics_;
}

// bytes data = 5;
inline void Log::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Log::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Log.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Log::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Log.data)
}
inline std::string* Log::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Log.data)
  return _s;
}
inline const std::string& Log::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void Log::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Log::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Log::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Log.data)
  return _impl_.data_.Release();
}
inline void Log::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Log.data)
}

// -------------------------------------------------------------------

// LogEntry

// repeated bytes topics = 1;
inline int LogEntry::_internal_topics_size() const {
  return _internal_topics().size();
}
inline int LogEntry::topics_size() const {
  return _internal_topics_size();
}
inline void LogEntry::clear_topics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_.Clear();
}
inline std::string* LogEntry::add_topics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_topics()->Add();
  // @@protoc_insertion_point(field_add_mutable:dataTypespb.LogEntry.topics)
  return _s;
}
inline const std::string& LogEntry::topics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.LogEntry.topics)
  return _internal_topics().Get(index);
}
inline std::string* LogEntry::mutable_topics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.LogEntry.topics)
  return _internal_mutable_topics()->Mutable(index);
}
inline void LogEntry::set_topics(int index, const std::string& value) {
  _internal_mutable_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dataTypespb.LogEntry.topics)
}
inline void LogEntry::set_topics(int index, std::string&& value) {
  _internal_mutable_topics()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dataTypespb.LogEntry.topics)
}
inline void LogEntry::set_topics(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dataTypespb.LogEntry.topics)
}
inline void LogEntry::set_topics(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_topics()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dataTypespb.LogEntry.topics)
}
inline void LogEntry::set_topics(int index, absl::string_view value) {
  _internal_mutable_topics()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:dataTypespb.LogEntry.topics)
}
inline void LogEntry::add_topics(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:dataTypespb.LogEntry.topics)
}
inline void LogEntry::add_topics(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:dataTypespb.LogEntry.topics)
}
inline void LogEntry::add_topics(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dataTypespb.LogEntry.topics)
}
inline void LogEntry::add_topics(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dataTypespb.LogEntry.topics)
}
inline void LogEntry::add_topics(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:dataTypespb.LogEntry.topics)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LogEntry::topics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.LogEntry.topics)
  return _internal_topics();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LogEntry::mutable_topics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.LogEntry.topics)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_topics();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LogEntry::_internal_topics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LogEntry::_internal_mutable_topics() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.topics_;
}

// bytes data = 2;
inline void LogEntry::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& LogEntry::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.LogEntry.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogEntry::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.LogEntry.data)
}
inline std::string* LogEntry::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:dataTypespb.LogEntry.data)
  return _s;
}
inline const std::string& LogEntry::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void LogEntry::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* LogEntry::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* LogEntry::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.LogEntry.data)
  return _impl_.data_.Release();
}
inline void LogEntry::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.LogEntry.data)
}

// -------------------------------------------------------------------

// Logs

// repeated .dataTypespb.Log list = 1;
inline int Logs::_internal_list_size() const {
  return _internal_list().size();
}
inline int Logs::list_size() const {
  return _internal_list_size();
}
inline void Logs::clear_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.list_.Clear();
}
inline ::dataTypespb::Log* Logs::mutable_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.Logs.list)
  return _internal_mutable_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* Logs::mutable_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.Logs.list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_list();
}
inline const ::dataTypespb::Log& Logs::list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Logs.list)
  return _internal_list().Get(index);
}
inline ::dataTypespb::Log* Logs::add_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dataTypespb::Log* _add = _internal_mutable_list()->Add();
  // @@protoc_insertion_point(field_add:dataTypespb.Logs.list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& Logs::list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.Logs.list)
  return _internal_list();
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>&
Logs::_internal_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.list_;
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>*
Logs::_internal_mutable_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.list_;
}

// -------------------------------------------------------------------

// Receipt

// bytes contractAddress = 1;
inline void Receipt::clear_contractaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.ClearToEmpty();
}
inline const std::string& Receipt::contractaddress() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Receipt.contractAddress)
  return _internal_contractaddress();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Receipt::set_contractaddress(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.Receipt.contractAddress)
}
inline std::string* Receipt::mutable_contractaddress() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contractaddress();
  // @@protoc_insertion_point(field_mutable:dataTypespb.Receipt.contractAddress)
  return _s;
}
inline const std::string& Receipt::_internal_contractaddress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contractaddress_.Get();
}
inline void Receipt::_internal_set_contractaddress(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.Set(value, GetArena());
}
inline std::string* Receipt::_internal_mutable_contractaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.contractaddress_.Mutable( GetArena());
}
inline std::string* Receipt::release_contractaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.Receipt.contractAddress)
  return _impl_.contractaddress_.Release();
}
inline void Receipt::set_allocated_contractaddress(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contractaddress_.IsDefault()) {
          _impl_.contractaddress_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.Receipt.contractAddress)
}

// bool status = 2;
inline void Receipt::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = false;
}
inline bool Receipt::status() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Receipt.status)
  return _internal_status();
}
inline void Receipt::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Receipt.status)
}
inline bool Receipt::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void Receipt::_internal_set_status(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = value;
}

// uint64 gasUsed = 3;
inline void Receipt::clear_gasused() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gasused_ = ::uint64_t{0u};
}
inline ::uint64_t Receipt::gasused() const {
  // @@protoc_insertion_point(field_get:dataTypespb.Receipt.gasUsed)
  return _internal_gasused();
}
inline void Receipt::set_gasused(::uint64_t value) {
  _internal_set_gasused(value);
  // @@protoc_insertion_point(field_set:dataTypespb.Receipt.gasUsed)
}
inline ::uint64_t Receipt::_internal_gasused() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gasused_;
}
inline void Receipt::_internal_set_gasused(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gasused_ = value;
}

// repeated .dataTypespb.Log logs = 4;
inline int Receipt::_internal_logs_size() const {
  return _internal_logs().size();
}
inline int Receipt::logs_size() const {
  return _internal_logs_size();
}
inline void Receipt::clear_logs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.logs_.Clear();
}
inline ::dataTypespb::Log* Receipt::mutable_logs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.Receipt.logs)
  return _internal_mutable_logs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>* Receipt::mutable_logs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.Receipt.logs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_logs();
}
inline const ::dataTypespb::Log& Receipt::logs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Receipt.logs)
  return _internal_logs().Get(index);
}
inline ::dataTypespb::Log* Receipt::add_logs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dataTypespb::Log* _add = _internal_mutable_logs()->Add();
  // @@protoc_insertion_point(field_add:dataTypespb.Receipt.logs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>& Receipt::logs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.Receipt.logs)
  return _internal_logs();
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>&
Receipt::_internal_logs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.logs_;
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Log>*
Receipt::_internal_mutable_logs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.logs_;
}

// -------------------------------------------------------------------

// Receipts

// repeated .dataTypespb.Receipt list = 1;
inline int Receipts::_internal_list_size() const {
  return _internal_list().size();
}
inline int Receipts::list_size() const {
  return _internal_list_size();
}
inline void Receipts::clear_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.list_.Clear();
}
inline ::dataTypespb::Receipt* Receipts::mutable_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.Receipts.list)
  return _internal_mutable_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>* Receipts::mutable_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.Receipts.list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_list();
}
inline const ::dataTypespb::Receipt& Receipts::list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.Receipts.list)
  return _internal_list().Get(index);
}
inline ::dataTypespb::Receipt* Receipts::add_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dataTypespb::Receipt* _add = _internal_mutable_list()->Add();
  // @@protoc_insertion_point(field_add:dataTypespb.Receipts.list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>& Receipts::list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.Receipts.list)
  return _internal_list();
}
inline const ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>&
Receipts::_internal_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.list_;
}
inline ::google::protobuf::RepeatedPtrField<::dataTypespb::Receipt>*
Receipts::_internal_mutable_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.list_;
}

// -------------------------------------------------------------------

// ReceiptHeader

// bytes contractAddress = 1;
inline void ReceiptHeader::clear_contractaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.ClearToEmpty();
}
inline const std::string& ReceiptHeader::contractaddress() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.ReceiptHeader.contractAddress)
  return _internal_contractaddress();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReceiptHeader::set_contractaddress(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dataTypespb.ReceiptHeader.contractAddress)
}
inline std::string* ReceiptHeader::mutable_contractaddress() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contractaddress();
  // @@protoc_insertion_point(field_mutable:dataTypespb.ReceiptHeader.contractAddress)
  return _s;
}
inline const std::string& ReceiptHeader::_internal_contractaddress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contractaddress_.Get();
}
inline void ReceiptHeader::_internal_set_contractaddress(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.Set(value, GetArena());
}
inline std::string* ReceiptHeader::_internal_mutable_contractaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.contractaddress_.Mutable( GetArena());
}
inline std::string* ReceiptHeader::release_contractaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dataTypespb.ReceiptHeader.contractAddress)
  return _impl_.contractaddress_.Release();
}
inline void ReceiptHeader::set_allocated_contractaddress(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contractaddress_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contractaddress_.IsDefault()) {
          _impl_.contractaddress_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dataTypespb.ReceiptHeader.contractAddress)
}

// bool status = 2;
inline void ReceiptHeader::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = false;
}
inline bool ReceiptHeader::status() const {
  // @@protoc_insertion_point(field_get:dataTypespb.ReceiptHeader.status)
  return _internal_status();
}
inline void ReceiptHeader::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:dataTypespb.ReceiptHeader.status)
}
inline bool ReceiptHeader::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void ReceiptHeader::_internal_set_status(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = value;
}

// uint64 gasUsed = 3;
inline void ReceiptHeader::clear_gasused() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gasused_ = ::uint64_t{0u};
}
inline ::uint64_t ReceiptHeader::gasused() const {
  // @@protoc_insertion_point(field_get:dataTypespb.ReceiptHeader.gasUsed)
  return _internal_gasused();
}
inline void ReceiptHeader::set_gasused(::uint64_t value) {
  _internal_set_gasused(value);
  // @@protoc_insertion_point(field_set:dataTypespb.ReceiptHeader.gasUsed)
}
inline ::uint64_t ReceiptHeader::_internal_gasused() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gasused_;
}
inline void ReceiptHeader::_internal_set_gasused(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gasused_ = value;
}

// repeated bytes logHashes = 4;
inline int ReceiptHeader::_internal_loghashes_size() const {
  return _internal_loghashes().size();
}
inline int ReceiptHeader::loghashes_size() const {
  return _internal_loghashes_size();
}
inline void ReceiptHeader::clear_loghashes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loghashes_.Clear();
}
inline std::string* ReceiptHeader::add_loghashes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_loghashes()->Add();
  // @@protoc_insertion_point(field_add_mutable:dataTypespb.ReceiptHeader.logHashes)
  return _s;
}
inline const std::string& ReceiptHeader::loghashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dataTypespb.ReceiptHeader.logHashes)
  return _internal_loghashes().Get(index);
}
inline std::string* ReceiptHeader::mutable_loghashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dataTypespb.ReceiptHeader.logHashes)
  return _internal_mutable_loghashes()->Mutable(index);
}
inline void ReceiptHeader::set_loghashes(int index, const std::string& value) {
  _internal_mutable_loghashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::set_loghashes(int index, std::string&& value) {
  _internal_mutable_loghashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::set_loghashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_loghashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::set_loghashes(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_loghashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::set_loghashes(int index, absl::string_view value) {
  _internal_mutable_loghashes()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::add_loghashes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::add_loghashes(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::add_loghashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::add_loghashes(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dataTypespb.ReceiptHeader.logHashes)
}
inline void ReceiptHeader::add_loghashes(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_loghashes()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:dataTypespb.ReceiptHeader.logHashes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReceiptHeader::loghashes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dataTypespb.ReceiptHeader.logHashes)
  return _internal_loghashes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReceiptHeader::mutable_loghashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dataTypespb.ReceiptHeader.logHashes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_loghashes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReceiptHeader::_internal_loghashes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loghashes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReceiptHeader::_internal_mutable_loghashes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.loghashes_;
}

// -------------------------------------------------------------------

// TransientNonce

// uint64 nonce = 1;
inline void TransientNonce::clear_nonce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t TransientNonce::nonce() const {
  // @@protoc_insertion_point(field_get:dataTypespb.TransientNonce.nonce)
  return _internal_nonce();
}
inline void TransientNonce::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:dataTypespb.TransientNonce.nonce)
}
inline ::uint64_t TransientNonce::_internal_nonce() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nonce_;
}
inline void TransientNonce::_internal_set_nonce(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nonce_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace dataTypespb


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dataTypespb::Account_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dataTypespb::Account_State>() {
  return ::dataTypespb::Account_State_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_dataTypespb_2fdataTypes_2eproto_2epb_2eh
